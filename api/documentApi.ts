/**
 * BoldSign API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';

import {
    ObjectSerializer, Authentication, VoidAuth, Interceptor,
    HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth, RequestFile, 
    AccessCodeDetail,AccessCodeDetails,BehalfDocumentRecords,ChangeRecipient,DocumentCreated,DocumentProperties,DocumentRecords,DocumentTags,EmbeddedDocumentRequest,EmbeddedSendCreated,EmbeddedSigningLink,ErrorResult,ExtendExpiry,PrefillFieldRequest,ReminderMessage,RemoveAuthentication,RevokeDocument,SendForSign,TeamDocumentRecords,
} from '../model';

import {
    HttpError,
    optionsI,
    returnTypeT,
    returnTypeI,
    generateFormData,
    toFormData,
    queryParamsSerializer,
    USER_AGENT,
} from './';

let defaultBasePath = 'https://api.boldsign.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================


export class DocumentApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = { 'User-Agent': USER_AGENT };
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
        'X-API-KEY': new ApiKeyAuth('header', 'X-API-KEY'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string) {
        if (basePath) {
            this.basePath = basePath;
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = { ...defaultHeaders, "User-Agent": USER_AGENT };
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(apikey: string) {
        this.authentications["X-API-KEY"].apiKey = apikey;
    }

    public setAccessToken(accessToken: string) {
        this.authentications["Bearer"].apiKey = 'bearer ' + accessToken;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * 
     * @summary The add authentication to recipient.
     * @param documentId The DocumentId.
     * @param accessCodeDetail Access code details.
     * @param options
     */
    public async addAuthentication (documentId: string, accessCodeDetail?: AccessCodeDetail, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        accessCodeDetail = deserializeIfNeeded(accessCodeDetail, "AccessCodeDetail");
        const localVarPath = this.basePath + '/v1/document/addAuthentication';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'documentId' is not null or undefined
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling addAuthentication.');
        }

        if (documentId !== undefined) {
            localVarQueryParameters['documentId'] = ObjectSerializer.serialize(documentId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(accessCodeDetail, AccessCodeDetail);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            accessCodeDetail,
            "AccessCodeDetail"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PATCH',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Add the Tags in Documents.
     * @param documentTags Contains DocumentId and LabelNames for Adding Tags.
     * @param options
     */
    public async addTag (documentTags?: DocumentTags, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        documentTags = deserializeIfNeeded(documentTags, "DocumentTags");
        const localVarPath = this.basePath + '/v1/document/addTags';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=full;IEEE754Compatible=false', 'application/json;odata.metadata=full;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=true', 'application/json;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.streaming=false;IEEE754Compatible=true', 'application/json;IEEE754Compatible=false', 'application/json;IEEE754Compatible=true', 'application/xml', 'text/plain', 'application/octet-stream', 'text/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(documentTags, DocumentTags);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            documentTags,
            "DocumentTags"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PATCH',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            400,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Gets the behalf documents.
     * @param page Page index specified in get document list request.
     * @param pageType The filter used to differentiate between documents sent on the user\&#39;s behalf and documents sent by the user on behalf of others. The API will return documents based on the specified value.
     * @param emailAddress The sender identity\&#39;s email used to filter the documents returned in the API. The API will return documents that were sent on behalf of the specified email address.
     * @param signers A list of signer email addresses used to filter the documents returned in the API. The API will return documents where the signer\&#39;s email address matches one of the email addresses provided in this list
     * @param pageSize Page size specified in get document list request.
     * @param startDate Start date of the document
     * @param status Status of the document such as In-progress, Completed, Decline, Expired, Revoked, Draft.
     * @param endDate End date of the document
     * @param searchKey Documents can be listed by the search key present in the document like document title, document ID, sender or recipient(s) name, etc.,
     * @param labels Labels of the document.
     * @param nextCursor Next cursor value for pagination, required for fetching the next set of documents beyond 10,000 records.
     * @param brandIds BrandId(s) of the document.
     * @param options
     */
    public async behalfDocuments (page: number, pageType?: 'BehalfOfOthers' | 'BehalfOfMe', emailAddress?: Array<string>, signers?: Array<string>, pageSize?: number, startDate?: Date, status?: Array<'None' | 'WaitingForMe' | 'WaitingForOthers' | 'NeedAttention' | 'Completed' | 'Declined' | 'Revoked' | 'Expired' | 'Draft' | 'Scheduled'>, endDate?: Date, searchKey?: string, labels?: Array<string>, nextCursor?: number, brandIds?: Array<string>, options: optionsI = {headers: {}}) : Promise<returnTypeT<BehalfDocumentRecords>> {
        const localVarPath = this.basePath + '/v1/document/behalfList';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling behalfDocuments.');
        }

        if (pageType !== undefined) {
            localVarQueryParameters['PageType'] = ObjectSerializer.serialize(pageType, "'BehalfOfOthers' | 'BehalfOfMe'");
        }

        if (emailAddress !== undefined) {
            localVarQueryParameters['EmailAddress'] = ObjectSerializer.serialize(emailAddress, "Array<string>");
        }

        if (signers !== undefined) {
            localVarQueryParameters['Signers'] = ObjectSerializer.serialize(signers, "Array<string>");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['StartDate'] = ObjectSerializer.serialize(startDate, "Date");
        }

        if (status !== undefined) {
            localVarQueryParameters['Status'] = ObjectSerializer.serialize(status, "Array<'None' | 'WaitingForMe' | 'WaitingForOthers' | 'NeedAttention' | 'Completed' | 'Declined' | 'Revoked' | 'Expired' | 'Draft' | 'Scheduled'>");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['EndDate'] = ObjectSerializer.serialize(endDate, "Date");
        }

        if (searchKey !== undefined) {
            localVarQueryParameters['SearchKey'] = ObjectSerializer.serialize(searchKey, "string");
        }

        if (labels !== undefined) {
            localVarQueryParameters['Labels'] = ObjectSerializer.serialize(labels, "Array<string>");
        }

        if (nextCursor !== undefined) {
            localVarQueryParameters['NextCursor'] = ObjectSerializer.serialize(nextCursor, "number");
        }

        if (brandIds !== undefined) {
            localVarQueryParameters['BrandIds'] = ObjectSerializer.serialize(brandIds, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(localVarFormParams);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeT<BehalfDocumentRecords>>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<BehalfDocumentRecords>(
                          resolve,
                          reject,
                          response,
                          "BehalfDocumentRecords",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "BehalfDocumentRecords",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Changes the access code for the given document signer.
     * @param documentId 
     * @param accessCodeDetails The new access code.
     * @param emailId 
     * @param zOrder 
     * @param options
     */
    public async changeAccessCode (documentId: string, accessCodeDetails: AccessCodeDetails, emailId?: string, zOrder?: number, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        accessCodeDetails = deserializeIfNeeded(accessCodeDetails, "AccessCodeDetails");
        const localVarPath = this.basePath + '/v1/document/changeAccessCode';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=full;IEEE754Compatible=false', 'application/json;odata.metadata=full;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=true', 'application/json;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.streaming=false;IEEE754Compatible=true', 'application/json;IEEE754Compatible=false', 'application/json;IEEE754Compatible=true', 'application/xml', 'text/plain', 'application/octet-stream', 'text/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'documentId' is not null or undefined
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling changeAccessCode.');
        }

        // verify required parameter 'accessCodeDetails' is not null or undefined
        if (accessCodeDetails === null || accessCodeDetails === undefined) {
            throw new Error('Required parameter accessCodeDetails was null or undefined when calling changeAccessCode.');
        }

        if (documentId !== undefined) {
            localVarQueryParameters['DocumentId'] = ObjectSerializer.serialize(documentId, "string");
        }

        if (emailId !== undefined) {
            localVarQueryParameters['EmailId'] = ObjectSerializer.serialize(emailId, "string");
        }

        if (zOrder !== undefined) {
            localVarQueryParameters['ZOrder'] = ObjectSerializer.serialize(zOrder, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(accessCodeDetails, AccessCodeDetails);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            accessCodeDetails,
            "AccessCodeDetails"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PATCH',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Change recipient details of a document.
     * @param documentId The documentID details.
     * @param changeRecipient The new recipient details.
     * @param options
     */
    public async changeRecipient (documentId: string, changeRecipient: ChangeRecipient, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        changeRecipient = deserializeIfNeeded(changeRecipient, "ChangeRecipient");
        const localVarPath = this.basePath + '/v1/document/changeRecipient';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=full;IEEE754Compatible=false', 'application/json;odata.metadata=full;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=true', 'application/json;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.streaming=false;IEEE754Compatible=true', 'application/json;IEEE754Compatible=false', 'application/json;IEEE754Compatible=true', 'application/xml', 'text/plain', 'application/octet-stream', 'text/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'documentId' is not null or undefined
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling changeRecipient.');
        }

        // verify required parameter 'changeRecipient' is not null or undefined
        if (changeRecipient === null || changeRecipient === undefined) {
            throw new Error('Required parameter changeRecipient was null or undefined when calling changeRecipient.');
        }

        if (documentId !== undefined) {
            localVarQueryParameters['documentId'] = ObjectSerializer.serialize(documentId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(changeRecipient, ChangeRecipient);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            changeRecipient,
            "ChangeRecipient"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PATCH',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Generates a send URL which embeds document sending process into your application.
     * @param embeddedDocumentRequest The embedded send document request body.
     * @param options
     */
    public async createEmbeddedRequestUrlDocument (embeddedDocumentRequest?: EmbeddedDocumentRequest, options: optionsI = {headers: {}}) : Promise<returnTypeT<EmbeddedSendCreated>> {
        embeddedDocumentRequest = deserializeIfNeeded(embeddedDocumentRequest, "EmbeddedDocumentRequest");
        const localVarPath = this.basePath + '/v1/document/createEmbeddedRequestUrl';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(embeddedDocumentRequest, EmbeddedDocumentRequest);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            embeddedDocumentRequest,
            "EmbeddedDocumentRequest"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeT<EmbeddedSendCreated>>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<EmbeddedSendCreated>(
                          resolve,
                          reject,
                          response,
                          "EmbeddedSendCreated",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            201,
                            "EmbeddedSendCreated",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            400,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            422,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Delete the document.
     * @param documentId Document Id.
     * @param deletePermanently Delete Permanently.
     * @param options
     */
    public async deleteDocument (documentId: string, deletePermanently?: boolean, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        const localVarPath = this.basePath + '/v1/document/delete';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=full;IEEE754Compatible=false', 'application/json;odata.metadata=full;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=true', 'application/json;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.streaming=false;IEEE754Compatible=true', 'application/json;IEEE754Compatible=false', 'application/json;IEEE754Compatible=true', 'application/xml', 'text/plain', 'application/octet-stream', 'text/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'documentId' is not null or undefined
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling deleteDocument.');
        }

        if (documentId !== undefined) {
            localVarQueryParameters['documentId'] = ObjectSerializer.serialize(documentId, "string");
        }

        if (deletePermanently !== undefined) {
            localVarQueryParameters['deletePermanently'] = ObjectSerializer.serialize(deletePermanently, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(localVarFormParams);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Delete the Tags in Documents.
     * @param documentTags Contains DocumentId and LabelNames for Adding Tags.
     * @param options
     */
    public async deleteTag (documentTags?: DocumentTags, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        documentTags = deserializeIfNeeded(documentTags, "DocumentTags");
        const localVarPath = this.basePath + '/v1/document/deleteTags';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=full;IEEE754Compatible=false', 'application/json;odata.metadata=full;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=true', 'application/json;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.streaming=false;IEEE754Compatible=true', 'application/json;IEEE754Compatible=false', 'application/json;IEEE754Compatible=true', 'application/xml', 'text/plain', 'application/octet-stream', 'text/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(documentTags, DocumentTags);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            documentTags,
            "DocumentTags"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            400,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Download the Attachment.
     * @param documentId Document Id.
     * @param attachmentId Attachment Id(Get attachment ID from Properties API).
     * @param onBehalfOf The on behalfof email address.
     * @param options
     */
    public async downloadAttachment (documentId: string, attachmentId: string, onBehalfOf?: string, options: optionsI = {headers: {}}) : Promise<returnTypeT<Buffer>> {
        const localVarPath = this.basePath + '/v1/document/downloadAttachment';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=full;IEEE754Compatible=false', 'application/json;odata.metadata=full;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=true', 'application/json;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.streaming=false;IEEE754Compatible=true', 'application/json;IEEE754Compatible=false', 'application/json;IEEE754Compatible=true', 'application/xml', 'text/plain', 'application/octet-stream', 'text/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'documentId' is not null or undefined
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling downloadAttachment.');
        }

        // verify required parameter 'attachmentId' is not null or undefined
        if (attachmentId === null || attachmentId === undefined) {
            throw new Error('Required parameter attachmentId was null or undefined when calling downloadAttachment.');
        }

        if (documentId !== undefined) {
            localVarQueryParameters['documentId'] = ObjectSerializer.serialize(documentId, "string");
        }

        if (attachmentId !== undefined) {
            localVarQueryParameters['attachmentId'] = ObjectSerializer.serialize(attachmentId, "string");
        }

        if (onBehalfOf !== undefined) {
            localVarQueryParameters['onBehalfOf'] = ObjectSerializer.serialize(onBehalfOf, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(localVarFormParams);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "arraybuffer",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeT<Buffer>>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<Buffer>(
                          resolve,
                          reject,
                          response,
                          "Buffer",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "RequestFile",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Download the audit trail document.
     * @param documentId Document Id.
     * @param onBehalfOf The on behalfof email address.
     * @param options
     */
    public async downloadAuditLog (documentId: string, onBehalfOf?: string, options: optionsI = {headers: {}}) : Promise<returnTypeT<Buffer>> {
        const localVarPath = this.basePath + '/v1/document/downloadAuditLog';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=full;IEEE754Compatible=false', 'application/json;odata.metadata=full;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=true', 'application/json;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.streaming=false;IEEE754Compatible=true', 'application/json;IEEE754Compatible=false', 'application/json;IEEE754Compatible=true', 'application/xml', 'text/plain', 'application/octet-stream', 'text/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'documentId' is not null or undefined
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling downloadAuditLog.');
        }

        if (documentId !== undefined) {
            localVarQueryParameters['documentId'] = ObjectSerializer.serialize(documentId, "string");
        }

        if (onBehalfOf !== undefined) {
            localVarQueryParameters['onBehalfOf'] = ObjectSerializer.serialize(onBehalfOf, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(localVarFormParams);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "arraybuffer",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeT<Buffer>>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<Buffer>(
                          resolve,
                          reject,
                          response,
                          "Buffer",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "RequestFile",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Download the document.
     * @param documentId Document Id.
     * @param onBehalfOf The on behalfof email address.
     * @param options
     */
    public async downloadDocument (documentId: string, onBehalfOf?: string, options: optionsI = {headers: {}}) : Promise<returnTypeT<Buffer>> {
        const localVarPath = this.basePath + '/v1/document/download';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=full;IEEE754Compatible=false', 'application/json;odata.metadata=full;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=true', 'application/json;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.streaming=false;IEEE754Compatible=true', 'application/json;IEEE754Compatible=false', 'application/json;IEEE754Compatible=true', 'application/xml', 'text/plain', 'application/octet-stream', 'text/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'documentId' is not null or undefined
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling downloadDocument.');
        }

        if (documentId !== undefined) {
            localVarQueryParameters['documentId'] = ObjectSerializer.serialize(documentId, "string");
        }

        if (onBehalfOf !== undefined) {
            localVarQueryParameters['onBehalfOf'] = ObjectSerializer.serialize(onBehalfOf, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(localVarFormParams);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "arraybuffer",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeT<Buffer>>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<Buffer>(
                          resolve,
                          reject,
                          response,
                          "Buffer",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "RequestFile",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Extends the expiration date of the document.
     * @param documentId Document Id.
     * @param extendExpiry The new expiry value should be specified in yyyy-MM-dd format for days type, ISO date time format for specific date time and integer for hours type.
     * @param options
     */
    public async extendExpiry (documentId: string, extendExpiry?: ExtendExpiry, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        extendExpiry = deserializeIfNeeded(extendExpiry, "ExtendExpiry");
        const localVarPath = this.basePath + '/v1/document/extendExpiry';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=full;IEEE754Compatible=false', 'application/json;odata.metadata=full;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=true', 'application/json;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.streaming=false;IEEE754Compatible=true', 'application/json;IEEE754Compatible=false', 'application/json;IEEE754Compatible=true', 'application/xml', 'text/plain', 'application/octet-stream', 'text/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'documentId' is not null or undefined
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling extendExpiry.');
        }

        if (documentId !== undefined) {
            localVarQueryParameters['documentId'] = ObjectSerializer.serialize(documentId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(extendExpiry, ExtendExpiry);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            extendExpiry,
            "ExtendExpiry"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PATCH',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Get sign link for Embedded Sign.
     * @param documentId 
     * @param signerEmail 
     * @param countryCode 
     * @param phoneNumber 
     * @param signLinkValidTill 
     * @param redirectUrl 
     * @param options
     */
    public async getEmbeddedSignLink (documentId: string, signerEmail?: string, countryCode?: string, phoneNumber?: string, signLinkValidTill?: Date, redirectUrl?: string, options: optionsI = {headers: {}}) : Promise<returnTypeT<EmbeddedSigningLink>> {
        const localVarPath = this.basePath + '/v1/document/getEmbeddedSignLink';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=full;IEEE754Compatible=false', 'application/json;odata.metadata=full;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=true', 'application/json;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.streaming=false;IEEE754Compatible=true', 'application/json;IEEE754Compatible=false', 'application/json;IEEE754Compatible=true', 'application/xml', 'text/plain', 'application/octet-stream', 'text/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'documentId' is not null or undefined
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling getEmbeddedSignLink.');
        }

        if (documentId !== undefined) {
            localVarQueryParameters['DocumentId'] = ObjectSerializer.serialize(documentId, "string");
        }

        if (signerEmail !== undefined) {
            localVarQueryParameters['SignerEmail'] = ObjectSerializer.serialize(signerEmail, "string");
        }

        if (countryCode !== undefined) {
            localVarQueryParameters['CountryCode'] = ObjectSerializer.serialize(countryCode, "string");
        }

        if (phoneNumber !== undefined) {
            localVarQueryParameters['PhoneNumber'] = ObjectSerializer.serialize(phoneNumber, "string");
        }

        if (signLinkValidTill !== undefined) {
            localVarQueryParameters['SignLinkValidTill'] = ObjectSerializer.serialize(signLinkValidTill, "Date");
        }

        if (redirectUrl !== undefined) {
            localVarQueryParameters['RedirectUrl'] = ObjectSerializer.serialize(redirectUrl, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(localVarFormParams);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeT<EmbeddedSigningLink>>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<EmbeddedSigningLink>(
                          resolve,
                          reject,
                          response,
                          "EmbeddedSigningLink",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "EmbeddedSigningLink",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Get summary of the document.
     * @param documentId Document Id.
     * @param options
     */
    public async getProperties (documentId: string, options: optionsI = {headers: {}}) : Promise<returnTypeT<DocumentProperties>> {
        const localVarPath = this.basePath + '/v1/document/properties';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'documentId' is not null or undefined
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling getProperties.');
        }

        if (documentId !== undefined) {
            localVarQueryParameters['documentId'] = ObjectSerializer.serialize(documentId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(localVarFormParams);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeT<DocumentProperties>>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<DocumentProperties>(
                          resolve,
                          reject,
                          response,
                          "DocumentProperties",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "DocumentProperties",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary List user documents.
     * @param page Page index specified in get document list request.
     * @param sentBy 
     * @param recipients 
     * @param transmitType 
     * @param pageSize Page size specified in get document list request.
     * @param startDate Start date of the document
     * @param status Status of the document such as In-progress, Completed, Decline, Expired, Revoked, Draft.
     * @param endDate End date of the document
     * @param searchKey Documents can be listed by the search key present in the document like document title, document ID, sender or recipient(s) name, etc.,
     * @param labels Labels of the document.
     * @param nextCursor Next cursor value for pagination, required for fetching the next set of documents beyond 10,000 records.
     * @param brandIds BrandId(s) of the document.
     * @param options
     */
    public async listDocuments (page: number, sentBy?: Array<string>, recipients?: Array<string>, transmitType?: 'Sent' | 'Received' | ' Both', pageSize?: number, startDate?: Date, status?: Array<'None' | 'WaitingForMe' | 'WaitingForOthers' | 'NeedAttention' | 'Completed' | 'Declined' | 'Revoked' | 'Expired' | 'Draft' | 'Scheduled'>, endDate?: Date, searchKey?: string, labels?: Array<string>, nextCursor?: number, brandIds?: Array<string>, options: optionsI = {headers: {}}) : Promise<returnTypeT<DocumentRecords>> {
        const localVarPath = this.basePath + '/v1/document/list';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling listDocuments.');
        }

        if (sentBy !== undefined) {
            localVarQueryParameters['SentBy'] = ObjectSerializer.serialize(sentBy, "Array<string>");
        }

        if (recipients !== undefined) {
            localVarQueryParameters['Recipients'] = ObjectSerializer.serialize(recipients, "Array<string>");
        }

        if (transmitType !== undefined) {
            localVarQueryParameters['TransmitType'] = ObjectSerializer.serialize(transmitType, "'Sent' | 'Received' | ' Both'");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['StartDate'] = ObjectSerializer.serialize(startDate, "Date");
        }

        if (status !== undefined) {
            localVarQueryParameters['Status'] = ObjectSerializer.serialize(status, "Array<'None' | 'WaitingForMe' | 'WaitingForOthers' | 'NeedAttention' | 'Completed' | 'Declined' | 'Revoked' | 'Expired' | 'Draft' | 'Scheduled'>");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['EndDate'] = ObjectSerializer.serialize(endDate, "Date");
        }

        if (searchKey !== undefined) {
            localVarQueryParameters['SearchKey'] = ObjectSerializer.serialize(searchKey, "string");
        }

        if (labels !== undefined) {
            localVarQueryParameters['Labels'] = ObjectSerializer.serialize(labels, "Array<string>");
        }

        if (nextCursor !== undefined) {
            localVarQueryParameters['NextCursor'] = ObjectSerializer.serialize(nextCursor, "number");
        }

        if (brandIds !== undefined) {
            localVarQueryParameters['BrandIds'] = ObjectSerializer.serialize(brandIds, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(localVarFormParams);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeT<DocumentRecords>>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<DocumentRecords>(
                          resolve,
                          reject,
                          response,
                          "DocumentRecords",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "DocumentRecords",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Updates the value (prefill) of the fields in the document.
     * @param documentId The DocumentId.
     * @param prefillFieldRequest The prefill field request.
     * @param options
     */
    public async prefillFields (documentId: string, prefillFieldRequest: PrefillFieldRequest, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        prefillFieldRequest = deserializeIfNeeded(prefillFieldRequest, "PrefillFieldRequest");
        const localVarPath = this.basePath + '/v1/document/prefillFields';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'documentId' is not null or undefined
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling prefillFields.');
        }

        // verify required parameter 'prefillFieldRequest' is not null or undefined
        if (prefillFieldRequest === null || prefillFieldRequest === undefined) {
            throw new Error('Required parameter prefillFieldRequest was null or undefined when calling prefillFields.');
        }

        if (documentId !== undefined) {
            localVarQueryParameters['documentId'] = ObjectSerializer.serialize(documentId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(prefillFieldRequest, PrefillFieldRequest);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            prefillFieldRequest,
            "PrefillFieldRequest"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PATCH',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Send reminder to pending signers.
     * @param documentId Document Id.
     * @param receiverEmails Signer emails.
     * @param reminderMessage Reminder Message for signers.
     * @param options
     */
    public async remindDocument (documentId: string, receiverEmails?: Array<string>, reminderMessage?: ReminderMessage, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        reminderMessage = deserializeIfNeeded(reminderMessage, "ReminderMessage");
        const localVarPath = this.basePath + '/v1/document/remind';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=full;IEEE754Compatible=false', 'application/json;odata.metadata=full;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=true', 'application/json;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.streaming=false;IEEE754Compatible=true', 'application/json;IEEE754Compatible=false', 'application/json;IEEE754Compatible=true', 'application/xml', 'text/plain', 'application/octet-stream', 'text/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'documentId' is not null or undefined
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling remindDocument.');
        }

        if (documentId !== undefined) {
            localVarQueryParameters['documentId'] = ObjectSerializer.serialize(documentId, "string");
        }

        if (receiverEmails !== undefined) {
            localVarQueryParameters['receiverEmails'] = ObjectSerializer.serialize(receiverEmails, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(reminderMessage, ReminderMessage);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            reminderMessage,
            "ReminderMessage"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Remove the access code for the given document signer.
     * @param documentId Document ID of the signature request
     * @param removeAuthentication To remove access code.
     * @param options
     */
    public async removeAuthentication (documentId: string, removeAuthentication?: RemoveAuthentication, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        removeAuthentication = deserializeIfNeeded(removeAuthentication, "RemoveAuthentication");
        const localVarPath = this.basePath + '/v1/document/RemoveAuthentication';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=full;IEEE754Compatible=false', 'application/json;odata.metadata=full;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=true', 'application/json;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.streaming=false;IEEE754Compatible=true', 'application/json;IEEE754Compatible=false', 'application/json;IEEE754Compatible=true', 'application/xml', 'text/plain', 'application/octet-stream', 'text/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'documentId' is not null or undefined
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling removeAuthentication.');
        }

        if (documentId !== undefined) {
            localVarQueryParameters['DocumentId'] = ObjectSerializer.serialize(documentId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(removeAuthentication, RemoveAuthentication);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            removeAuthentication,
            "RemoveAuthentication"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PATCH',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Revoke the document.
     * @param documentId Document Id.
     * @param revokeDocument RevokeDetails.
     * @param options
     */
    public async revokeDocument (documentId: string, revokeDocument: RevokeDocument, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        revokeDocument = deserializeIfNeeded(revokeDocument, "RevokeDocument");
        const localVarPath = this.basePath + '/v1/document/revoke';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'documentId' is not null or undefined
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling revokeDocument.');
        }

        // verify required parameter 'revokeDocument' is not null or undefined
        if (revokeDocument === null || revokeDocument === undefined) {
            throw new Error('Required parameter revokeDocument was null or undefined when calling revokeDocument.');
        }

        if (documentId !== undefined) {
            localVarQueryParameters['documentId'] = ObjectSerializer.serialize(documentId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(revokeDocument, RevokeDocument);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            revokeDocument,
            "RevokeDocument"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Sends the document for sign.
     * @param sendForSign The send for sign request body.
     * @param options
     */
    public async sendDocument (sendForSign?: SendForSign, options: optionsI = {headers: {}}) : Promise<returnTypeT<DocumentCreated>> {
        sendForSign = deserializeIfNeeded(sendForSign, "SendForSign");
        const localVarPath = this.basePath + '/v1/document/send';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(sendForSign, SendForSign);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            sendForSign,
            "SendForSign"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeT<DocumentCreated>>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<DocumentCreated>(
                          resolve,
                          reject,
                          response,
                          "DocumentCreated",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            201,
                            "DocumentCreated",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            400,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            422,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Get user Team documents.
     * @param page Page index specified in get document list request.
     * @param userId UserId of the  Team document.
     * @param teamId TeamId  of the  Team document.
     * @param transmitType Transmit type as Sent, Received and Both.
     * @param pageSize Page size specified in get document list request.
     * @param startDate Start date of the document
     * @param status Status of the document such as In-progress, Completed, Decline, Expired, Revoked, Draft.
     * @param endDate End date of the document
     * @param searchKey Documents can be listed by the search key present in the document like document title, document ID, sender or recipient(s) name, etc.,
     * @param labels Labels of the document.
     * @param nextCursor Next cursor value for pagination, required for fetching the next set of documents beyond 10,000 records.
     * @param brandIds BrandId(s) of the document.
     * @param options
     */
    public async teamDocuments (page: number, userId?: Array<string>, teamId?: Array<string>, transmitType?: 'Sent' | 'Received' | ' Both', pageSize?: number, startDate?: Date, status?: Array<'None' | 'WaitingForMe' | 'WaitingForOthers' | 'NeedAttention' | 'Completed' | 'Declined' | 'Revoked' | 'Expired' | 'Draft' | 'Scheduled'>, endDate?: Date, searchKey?: string, labels?: Array<string>, nextCursor?: number, brandIds?: Array<string>, options: optionsI = {headers: {}}) : Promise<returnTypeT<TeamDocumentRecords>> {
        const localVarPath = this.basePath + '/v1/document/teamlist';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling teamDocuments.');
        }

        if (userId !== undefined) {
            localVarQueryParameters['UserId'] = ObjectSerializer.serialize(userId, "Array<string>");
        }

        if (teamId !== undefined) {
            localVarQueryParameters['TeamId'] = ObjectSerializer.serialize(teamId, "Array<string>");
        }

        if (transmitType !== undefined) {
            localVarQueryParameters['TransmitType'] = ObjectSerializer.serialize(transmitType, "'Sent' | 'Received' | ' Both'");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['StartDate'] = ObjectSerializer.serialize(startDate, "Date");
        }

        if (status !== undefined) {
            localVarQueryParameters['Status'] = ObjectSerializer.serialize(status, "Array<'None' | 'WaitingForMe' | 'WaitingForOthers' | 'NeedAttention' | 'Completed' | 'Declined' | 'Revoked' | 'Expired' | 'Draft' | 'Scheduled'>");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['EndDate'] = ObjectSerializer.serialize(endDate, "Date");
        }

        if (searchKey !== undefined) {
            localVarQueryParameters['SearchKey'] = ObjectSerializer.serialize(searchKey, "string");
        }

        if (labels !== undefined) {
            localVarQueryParameters['Labels'] = ObjectSerializer.serialize(labels, "Array<string>");
        }

        if (nextCursor !== undefined) {
            localVarQueryParameters['NextCursor'] = ObjectSerializer.serialize(nextCursor, "number");
        }

        if (brandIds !== undefined) {
            localVarQueryParameters['BrandIds'] = ObjectSerializer.serialize(brandIds, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(localVarFormParams);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeT<TeamDocumentRecords>>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<TeamDocumentRecords>(
                          resolve,
                          reject,
                          response,
                          "TeamDocumentRecords",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "TeamDocumentRecords",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
}

function deserializeIfNeeded<T> (obj: T, classname: string): T {
  if (obj !== null && obj !== undefined && obj.constructor.name !== classname) {
    return ObjectSerializer.deserialize(obj, classname);
  }

  return obj;
}

type AxiosResolve<T> = (
  value: (returnTypeT<T> | PromiseLike<returnTypeT<T>>),
) => void

type AxiosReject = (reason?: any) => void;

function handleSuccessfulResponse<T>(
  resolve: AxiosResolve<T>,
  reject: AxiosReject,
  response: AxiosResponse,
  returnType?: string,
) {
    let body = response.data;

    if (
        response.status &&
        response.status >= 200 &&
        response.status <= 299
    ) {
        if (returnType) {
            body = ObjectSerializer.deserialize(body, returnType);
        }

        resolve({ response: response, body: body });
    } else {
        reject(new HttpError(response, body, response.status));
    }
}

function handleErrorCodeResponse(
  reject: AxiosReject,
  response: AxiosResponse,
  code: number,
  returnType: string
): boolean {
    if (response.status !== code) {
        return false;
    }

    const body = ObjectSerializer.deserialize(
        response.data,
        returnType,
    );

    reject(new HttpError(response, body, response.status));

    return true;
}

function handleErrorRangeResponse(
  reject: AxiosReject,
  response: AxiosResponse,
  code: string,
  returnType: string
): boolean {
    let rangeCodeLeft = Number(code[0] + "00");
    let rangeCodeRight = Number(code[0] + "99");

    if (response.status >= rangeCodeLeft && response.status <= rangeCodeRight) {
        const body = ObjectSerializer.deserialize(
            response.data,
            returnType,
        );

      reject(new HttpError(response, body, response.status));

      return true;
    }

    return false;
}
