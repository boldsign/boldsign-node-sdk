/**
 * BoldSign API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';

import {
    ObjectSerializer, Authentication, VoidAuth, Interceptor,
    HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth, RequestFile, 
    DownloadImageRequest,EmbeddedFileDetails,EmbeddedFileLink,ErrorResult,IdReport,VerificationDataRequest,
} from '../model';

import {
    HttpError,
    optionsI,
    returnTypeT,
    returnTypeI,
    generateFormData,
    toFormData,
    queryParamsSerializer,
    USER_AGENT,
} from './';

let defaultBasePath = 'https://api.boldsign.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================


export class IdentityVerificationApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = { 'User-Agent': USER_AGENT };
    protected _useQuerystring : boolean = true;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
        'X-API-KEY': new ApiKeyAuth('header', 'X-API-KEY'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string) {
        if (basePath) {
            this.basePath = basePath;
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = { ...defaultHeaders, "User-Agent": USER_AGENT };
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(apikey: string) {
        this.authentications["X-API-KEY"].apiKey = apikey;
    }

    public setAccessToken(accessToken: string) {
        this.authentications["Bearer"].apiKey = 'bearer ' + accessToken;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * 
     * @summary Generate a URL that embeds manual ID verification for the specified document signer into your application.
     * @param documentId The document id.
     * @param embeddedFileDetails The embedded verification link request.
     * @param options
     */
    public async createEmbeddedVerificationUrl (documentId: string, embeddedFileDetails?: EmbeddedFileDetails, options: optionsI = {headers: {}}) : Promise<EmbeddedFileLink> {
        embeddedFileDetails = deserializeIfNeeded(embeddedFileDetails, "EmbeddedFileDetails");
        const localVarPath = this.basePath + '/v1/identityVerification/createEmbeddedVerificationUrl';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'documentId' is not null or undefined
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling createEmbeddedVerificationUrl.');
        }

        if (documentId !== undefined) {
            localVarQueryParameters['documentId'] = ObjectSerializer.serialize(documentId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(embeddedFileDetails, EmbeddedFileDetails);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            embeddedFileDetails,
            "EmbeddedFileDetails"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<EmbeddedFileLink>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<EmbeddedFileLink>(
                          resolve,
                          reject,
                          response,
                          "EmbeddedFileLink",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "EmbeddedFileLink",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Retrieve the uploaded ID verification document or selfie image for the specified document signer using the file ID.
     * @param documentId The document id.
     * @param downloadImageRequest The download image request.
     * @param options
     */
    public async image (documentId: string, downloadImageRequest: DownloadImageRequest, options: optionsI = {headers: {}}) : Promise<Buffer> {
        downloadImageRequest = deserializeIfNeeded(downloadImageRequest, "DownloadImageRequest");
        const localVarPath = this.basePath + '/v1/identityVerification/image';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=minimal;IEEE754Compatible=false', 'application/json;odata.metadata=minimal;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=full;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=full;IEEE754Compatible=false', 'application/json;odata.metadata=full;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.metadata=none;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=true', 'application/json;odata.metadata=none;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=false', 'application/json;odata.metadata=none;IEEE754Compatible=true', 'application/json;odata.streaming=true;IEEE754Compatible=false', 'application/json;odata.streaming=true;IEEE754Compatible=true', 'application/json;odata.streaming=false;IEEE754Compatible=false', 'application/json;odata.streaming=false;IEEE754Compatible=true', 'application/json;IEEE754Compatible=false', 'application/json;IEEE754Compatible=true', 'application/xml', 'text/plain', 'application/octet-stream', 'text/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'documentId' is not null or undefined
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling image.');
        }

        // verify required parameter 'downloadImageRequest' is not null or undefined
        if (downloadImageRequest === null || downloadImageRequest === undefined) {
            throw new Error('Required parameter downloadImageRequest was null or undefined when calling image.');
        }

        if (documentId !== undefined) {
            localVarQueryParameters['documentId'] = ObjectSerializer.serialize(documentId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(downloadImageRequest, DownloadImageRequest);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            downloadImageRequest,
            "DownloadImageRequest"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "arraybuffer",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<Buffer>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<Buffer>(
                          resolve,
                          reject,
                          response,
                          "Buffer",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "RequestFile",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            400,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Retrieve the ID verification report for the specified document signer.
     * @param documentId The document id.
     * @param verificationDataRequest The download image request.
     * @param options
     */
    public async report (documentId: string, verificationDataRequest: VerificationDataRequest, options: optionsI = {headers: {}}) : Promise<IdReport> {
        verificationDataRequest = deserializeIfNeeded(verificationDataRequest, "VerificationDataRequest");
        const localVarPath = this.basePath + '/v1/identityVerification/report';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'documentId' is not null or undefined
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling report.');
        }

        // verify required parameter 'verificationDataRequest' is not null or undefined
        if (verificationDataRequest === null || verificationDataRequest === undefined) {
            throw new Error('Required parameter verificationDataRequest was null or undefined when calling report.');
        }

        if (documentId !== undefined) {
            localVarQueryParameters['documentId'] = ObjectSerializer.serialize(documentId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(verificationDataRequest, VerificationDataRequest);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            verificationDataRequest,
            "VerificationDataRequest"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<IdReport>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<IdReport>(
                          resolve,
                          reject,
                          response,
                          "IdReport",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "IdReport",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            400,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
}

function deserializeIfNeeded<T> (obj: T, classname: string): T {
  if (obj !== null && obj !== undefined && obj.constructor.name !== classname) {
    return ObjectSerializer.deserialize(obj, classname);
  }

  return obj;
}

type AxiosResolve<T> = (
  value: (T | PromiseLike<T>),
) => void

type AxiosReject = (reason?: any) => void;

function handleSuccessfulResponse<T>(
  resolve: AxiosResolve<T>,
  reject: AxiosReject,
  response: AxiosResponse,
  returnType?: string,
) {
    let body = response.data;

    if (
        response.status &&
        response.status >= 200 &&
        response.status <= 299
    ) {
        if (returnType) {
            body = ObjectSerializer.deserialize(body, returnType);
        }

        resolve(body);
    } else {
        reject(new HttpError(response, body, response.status));
    }
}

function handleErrorCodeResponse(
  reject: AxiosReject,
  response: AxiosResponse,
  code: number,
  returnType: string
): boolean {
    if (response.status !== code) {
        return false;
    }

    let body = response.data;
    if(code === 401) {
        body = "Unauthorized request (401): Invalid authentication.";
    }
    reject(new HttpError(response, body, response.status));

    return true;
}

function handleErrorRangeResponse(
  reject: AxiosReject,
  response: AxiosResponse,
  code: string,
  returnType: string
): boolean {
    let rangeCodeLeft = Number(code[0] + "00");
    let rangeCodeRight = Number(code[0] + "99");

    if (response.status >= rangeCodeLeft && response.status <= rangeCodeRight) {
        const body = ObjectSerializer.deserialize(
            response.data,
            returnType,
        );

      reject(new HttpError(response, body, response.status));

      return true;
    }

    return false;
}
