/**
 * BoldSign API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';

import {
    ObjectSerializer, Authentication, VoidAuth, Interceptor,
    HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth, RequestFile, 
    CreateSenderIdentityRequest,EditSenderIdentityRequest,ErrorResult,SenderIdentityCreated,SenderIdentityList,
} from '../model';

import {
    HttpError,
    optionsI,
    returnTypeT,
    returnTypeI,
    generateFormData,
    toFormData,
    queryParamsSerializer,
    USER_AGENT,
} from './';

let defaultBasePath = 'https://api.boldsign.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================


export class SenderIdentitiesApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = { 'User-Agent': USER_AGENT };
    protected _useQuerystring : boolean = true;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
        'X-API-KEY': new ApiKeyAuth('header', 'X-API-KEY'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string) {
        if (basePath) {
            this.basePath = basePath;
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = { ...defaultHeaders, "User-Agent": USER_AGENT };
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(apikey: string) {
        this.authentications["X-API-KEY"].apiKey = apikey;
    }

    public setAccessToken(accessToken: string) {
        this.authentications["Bearer"].apiKey = 'bearer ' + accessToken;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * 
     * @summary Creates sender identity.
     * @param createSenderIdentityRequest The create sender identity request.
     * @param options
     */
    public async createSenderIdentities (createSenderIdentityRequest: CreateSenderIdentityRequest, options: optionsI = {headers: {}}) : Promise<SenderIdentityCreated> {
        createSenderIdentityRequest = deserializeIfNeeded(createSenderIdentityRequest, "CreateSenderIdentityRequest");
        const localVarPath = this.basePath + '/v1/senderIdentities/create';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'createSenderIdentityRequest' is not null or undefined
        if (createSenderIdentityRequest === null || createSenderIdentityRequest === undefined) {
            throw new Error('Required parameter createSenderIdentityRequest was null or undefined when calling createSenderIdentities.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(createSenderIdentityRequest, CreateSenderIdentityRequest);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            createSenderIdentityRequest,
            "CreateSenderIdentityRequest"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<SenderIdentityCreated>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<SenderIdentityCreated>(
                          resolve,
                          reject,
                          response,
                          "SenderIdentityCreated",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            201,
                            "SenderIdentityCreated",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            400,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Deletes sender identity.
     * @param email The email address.
     * @param options
     */
    public async deleteSenderIdentities (email: string, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        const localVarPath = this.basePath + '/v1/senderIdentities/delete';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling deleteSenderIdentities.');
        }

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(localVarFormParams);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Lists sender identity.
     * @param page Page index specified in get sender identity request.
     * @param pageSize Page size specified in get sender identity list request.
     * @param search Users can be listed by the search key present in the sender identity like sender identity name and email address
     * @param brandIds A list of brand IDs to filter associated with the sender identity.
     * @param options
     */
    public async listSenderIdentities (page: number, pageSize?: number, search?: string, brandIds?: Array<string>, options: optionsI = {headers: {}}) : Promise<SenderIdentityList> {
        const localVarPath = this.basePath + '/v1/senderIdentities/list';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling listSenderIdentities.');
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (search !== undefined) {
            localVarQueryParameters['Search'] = ObjectSerializer.serialize(search, "string");
        }

        if (brandIds !== undefined) {
            localVarQueryParameters['BrandIds'] = ObjectSerializer.serialize(brandIds, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(localVarFormParams);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<SenderIdentityList>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<SenderIdentityList>(
                          resolve,
                          reject,
                          response,
                          "SenderIdentityList",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "SenderIdentityList",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Rerequests denied sender identity.
     * @param email The email address.
     * @param options
     */
    public async reRequestSenderIdentities (email: string, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        const localVarPath = this.basePath + '/v1/senderIdentities/rerequest';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling reRequestSenderIdentities.');
        }

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(localVarFormParams);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Resends sender identity invitation.
     * @param email The email address.
     * @param options
     */
    public async resendInvitationSenderIdentities (email: string, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        const localVarPath = this.basePath + '/v1/senderIdentities/resendInvitation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling resendInvitationSenderIdentities.');
        }

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(localVarFormParams);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Updates sender identity.
     * @param email The email address.
     * @param editSenderIdentityRequest The create sender identity request.
     * @param options
     */
    public async updateSenderIdentities (email: string, editSenderIdentityRequest: EditSenderIdentityRequest, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        editSenderIdentityRequest = deserializeIfNeeded(editSenderIdentityRequest, "EditSenderIdentityRequest");
        const localVarPath = this.basePath + '/v1/senderIdentities/update';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling updateSenderIdentities.');
        }

        // verify required parameter 'editSenderIdentityRequest' is not null or undefined
        if (editSenderIdentityRequest === null || editSenderIdentityRequest === undefined) {
            throw new Error('Required parameter editSenderIdentityRequest was null or undefined when calling updateSenderIdentities.');
        }

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(editSenderIdentityRequest, EditSenderIdentityRequest);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            editSenderIdentityRequest,
            "EditSenderIdentityRequest"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method !== 'GET') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();

        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["Bearer"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["Bearer"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
}

function deserializeIfNeeded<T> (obj: T, classname: string): T {
  if (obj !== null && obj !== undefined && obj.constructor.name !== classname) {
    return ObjectSerializer.deserialize(obj, classname);
  }

  return obj;
}

type AxiosResolve<T> = (
  value: (T | PromiseLike<T>),
) => void

type AxiosReject = (reason?: any) => void;

function handleSuccessfulResponse<T>(
  resolve: AxiosResolve<T>,
  reject: AxiosReject,
  response: AxiosResponse,
  returnType?: string,
) {
    let body = response.data;

    if (
        response.status &&
        response.status >= 200 &&
        response.status <= 299
    ) {
        if (returnType) {
            body = ObjectSerializer.deserialize(body, returnType);
        }

        resolve(body);
    } else {
        reject(new HttpError(response, body, response.status));
    }
}

function handleErrorCodeResponse(
  reject: AxiosReject,
  response: AxiosResponse,
  code: number,
  returnType: string
): boolean {
    if (response.status !== code) {
        return false;
    }

    let body = response.data;
    if(code === 401) {
        body = "Unauthorized request (401): Invalid authentication.";
    }
    reject(new HttpError(response, body, response.status));

    return true;
}

function handleErrorRangeResponse(
  reject: AxiosReject,
  response: AxiosResponse,
  code: string,
  returnType: string
): boolean {
    let rangeCodeLeft = Number(code[0] + "00");
    let rangeCodeRight = Number(code[0] + "99");

    if (response.status >= rangeCodeLeft && response.status <= rangeCodeRight) {
        const body = ObjectSerializer.deserialize(
            response.data,
            returnType,
        );

      reject(new HttpError(response, body, response.status));

      return true;
    }

    return false;
}
