/**
 * BoldSign API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';

import {
    ObjectSerializer, Authentication, VoidAuth, Interceptor,
    HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth, RequestFile, 
    CreateTemplateRequest,DocumentCreated,EditTemplateRequest,EmbeddedCreateTemplateRequest,EmbeddedSendCreated,EmbeddedSendTemplateFormRequest,EmbeddedTemplateCreated,EmbeddedTemplateEditRequest,EmbeddedTemplateEdited,ErrorResult,MergeAndSendForSignForm,ProblemDetails,SendForSignFromTemplateForm,TemplateCreated,TemplateProperties,TemplateRecords,TemplateTag,
} from '../model';

import {
    HttpError,
    optionsI,
    returnTypeT,
    returnTypeI,
    generateFormData,
    toFormData,
    queryParamsSerializer,
    USER_AGENT,
} from './';

let defaultBasePath = 'https://api.boldsign.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================


export class TemplateApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = { 'User-Agent': USER_AGENT };
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
        'X-API-KEY': new ApiKeyAuth('header', 'X-API-KEY'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string) {
        if (basePath) {
            this.basePath = basePath;
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = { ...defaultHeaders, "User-Agent": USER_AGENT };
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(apikey: string) {
        this.authentications["X-API-KEY"].apiKey = apikey;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * 
     * @summary Add the Tags in Templates.
     * @param templateTag ContainsTemplateId and Label Names for AddingTags.
     * @param options
     */
    public async addTag (templateTag?: TemplateTag, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        templateTag = deserializeIfNeeded(templateTag, "TemplateTag");
        const localVarPath = this.basePath + '/v1/template/addTags';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/xml', 'application/prs.odatatestxx-odata', 'text/plain', 'text/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(templateTag, TemplateTag);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            templateTag,
            "TemplateTag"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PATCH',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method === 'POST') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            400,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Generates a send URL using a template which embeds document sending process into your application.
     * @param templateId The template id.
     * @param embeddedSendTemplateFormRequest Embedded send template json request.
     * @param options
     */
    public async createEmbeddedRequestUrlTemplate (templateId: string, embeddedSendTemplateFormRequest?: EmbeddedSendTemplateFormRequest, options: optionsI = {headers: {}}) : Promise<returnTypeT<EmbeddedSendCreated>> {
        embeddedSendTemplateFormRequest = deserializeIfNeeded(embeddedSendTemplateFormRequest, "EmbeddedSendTemplateFormRequest");
        const localVarPath = this.basePath + '/v1/template/createEmbeddedRequestUrl';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling createEmbeddedRequestUrlTemplate.');
        }

        if (templateId !== undefined) {
            localVarQueryParameters['templateId'] = ObjectSerializer.serialize(templateId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(embeddedSendTemplateFormRequest, EmbeddedSendTemplateFormRequest);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            embeddedSendTemplateFormRequest,
            "EmbeddedSendTemplateFormRequest"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method === 'POST') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeT<EmbeddedSendCreated>>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<EmbeddedSendCreated>(
                          resolve,
                          reject,
                          response,
                          "EmbeddedSendCreated",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "EmbeddedSendCreated",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            201,
                            "EmbeddedSendCreated",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Generates a create URL to embeds template create process into your application.
     * @param embeddedCreateTemplateRequest The create embedded template request body.
     * @param options
     */
    public async createEmbeddedTemplateUrl (embeddedCreateTemplateRequest?: EmbeddedCreateTemplateRequest, options: optionsI = {headers: {}}) : Promise<returnTypeT<EmbeddedTemplateCreated>> {
        embeddedCreateTemplateRequest = deserializeIfNeeded(embeddedCreateTemplateRequest, "EmbeddedCreateTemplateRequest");
        const localVarPath = this.basePath + '/v1/template/createEmbeddedTemplateUrl';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(embeddedCreateTemplateRequest, EmbeddedCreateTemplateRequest);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            embeddedCreateTemplateRequest,
            "EmbeddedCreateTemplateRequest"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method === 'POST') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeT<EmbeddedTemplateCreated>>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<EmbeddedTemplateCreated>(
                          resolve,
                          reject,
                          response,
                          "EmbeddedTemplateCreated",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "EmbeddedTemplateCreated",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            201,
                            "EmbeddedTemplateCreated",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Creates a new template.
     * @param createTemplateRequest The create template request body.
     * @param options
     */
    public async createTemplate (createTemplateRequest?: CreateTemplateRequest, options: optionsI = {headers: {}}) : Promise<returnTypeT<TemplateCreated>> {
        createTemplateRequest = deserializeIfNeeded(createTemplateRequest, "CreateTemplateRequest");
        const localVarPath = this.basePath + '/v1/template/create';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(createTemplateRequest, CreateTemplateRequest);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            createTemplateRequest,
            "CreateTemplateRequest"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method === 'POST') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeT<TemplateCreated>>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<TemplateCreated>(
                          resolve,
                          reject,
                          response,
                          "TemplateCreated",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            201,
                            "TemplateCreated",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Delete the Tags in Templates.
     * @param templateTag Contains TemplateId and LabelNames for Adding Tags.
     * @param options
     */
    public async deleteTag (templateTag?: TemplateTag, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        templateTag = deserializeIfNeeded(templateTag, "TemplateTag");
        const localVarPath = this.basePath + '/v1/template/deleteTags';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json;odata.metadata=minimal;odata.streaming=true', 'application/json;odata.metadata=minimal;odata.streaming=false', 'application/json;odata.metadata=minimal', 'application/json;odata.metadata=full;odata.streaming=true', 'application/json;odata.metadata=full;odata.streaming=false', 'application/json;odata.metadata=full', 'application/json;odata.metadata=none;odata.streaming=true', 'application/json;odata.metadata=none;odata.streaming=false', 'application/json;odata.metadata=none', 'application/json;odata.streaming=true', 'application/json;odata.streaming=false', 'application/json', 'application/xml', 'application/prs.odatatestxx-odata', 'text/plain', 'text/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(templateTag, TemplateTag);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            templateTag,
            "TemplateTag"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method === 'POST') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            400,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Deletes a template.
     * @param templateId The template id.
     * @param onBehalfOf The on behalfof email address.
     * @param options
     */
    public async deleteTemplate (templateId: string, onBehalfOf?: string, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        const localVarPath = this.basePath + '/v1/template/delete';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling deleteTemplate.');
        }

        if (templateId !== undefined) {
            localVarQueryParameters['templateId'] = ObjectSerializer.serialize(templateId, "string");
        }

        if (onBehalfOf !== undefined) {
            localVarQueryParameters['onBehalfOf'] = ObjectSerializer.serialize(onBehalfOf, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(localVarFormParams);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method === 'POST') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ProblemDetails",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ProblemDetails",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Download the template.
     * @param templateId Template Id.
     * @param onBehalfOf The on behalfof email address.
     * @param options
     */
    public async download (templateId: string, onBehalfOf?: string, options: optionsI = {headers: {}}) : Promise<returnTypeT<Buffer>> {
        const localVarPath = this.basePath + '/v1/template/download';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling download.');
        }

        if (templateId !== undefined) {
            localVarQueryParameters['templateId'] = ObjectSerializer.serialize(templateId, "string");
        }

        if (onBehalfOf !== undefined) {
            localVarQueryParameters['onBehalfOf'] = ObjectSerializer.serialize(onBehalfOf, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(localVarFormParams);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "arraybuffer",
        };

        if (localVarRequestOptions.method === 'POST') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeT<Buffer>>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<Buffer>(
                          resolve,
                          reject,
                          response,
                          "Buffer",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "RequestFile",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            400,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Edit and updates an existing template.
     * @param templateId The template id.
     * @param editTemplateRequest The edit template request body.
     * @param options
     */
    public async editTemplate (templateId: string, editTemplateRequest: EditTemplateRequest, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        editTemplateRequest = deserializeIfNeeded(editTemplateRequest, "EditTemplateRequest");
        const localVarPath = this.basePath + '/v1/template/edit';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling editTemplate.');
        }

        // verify required parameter 'editTemplateRequest' is not null or undefined
        if (editTemplateRequest === null || editTemplateRequest === undefined) {
            throw new Error('Required parameter editTemplateRequest was null or undefined when calling editTemplate.');
        }

        if (templateId !== undefined) {
            localVarQueryParameters['templateId'] = ObjectSerializer.serialize(templateId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(editTemplateRequest, EditTemplateRequest);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            editTemplateRequest,
            "EditTemplateRequest"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method === 'POST') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }



                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Generates a edit URL to embeds template edit process into your application.
     * @param templateId The template id.
     * @param embeddedTemplateEditRequest The embedded edit template request body.
     * @param options
     */
    public async getEmbeddedTemplateEditUrl (templateId: string, embeddedTemplateEditRequest?: EmbeddedTemplateEditRequest, options: optionsI = {headers: {}}) : Promise<returnTypeT<EmbeddedTemplateEdited>> {
        embeddedTemplateEditRequest = deserializeIfNeeded(embeddedTemplateEditRequest, "EmbeddedTemplateEditRequest");
        const localVarPath = this.basePath + '/v1/template/getEmbeddedTemplateEditUrl';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling getEmbeddedTemplateEditUrl.');
        }

        if (templateId !== undefined) {
            localVarQueryParameters['templateId'] = ObjectSerializer.serialize(templateId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(embeddedTemplateEditRequest, EmbeddedTemplateEditRequest);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            embeddedTemplateEditRequest,
            "EmbeddedTemplateEditRequest"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method === 'POST') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeT<EmbeddedTemplateEdited>>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<EmbeddedTemplateEdited>(
                          resolve,
                          reject,
                          response,
                          "EmbeddedTemplateEdited",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "EmbeddedTemplateEdited",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            201,
                            "EmbeddedTemplateEdited",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Get summary of the template.
     * @param templateId Template Id.
     * @param options
     */
    public async getProperties (templateId: string, options: optionsI = {headers: {}}) : Promise<returnTypeT<TemplateProperties>> {
        const localVarPath = this.basePath + '/v1/template/properties';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling getProperties.');
        }

        if (templateId !== undefined) {
            localVarQueryParameters['templateId'] = ObjectSerializer.serialize(templateId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(localVarFormParams);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method === 'POST') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeT<TemplateProperties>>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<TemplateProperties>(
                          resolve,
                          reject,
                          response,
                          "TemplateProperties",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "TemplateProperties",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ErrorResult",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            403,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary List all the templates.
     * @param page 
     * @param templateType 
     * @param pageSize 
     * @param searchKey 
     * @param onBehalfOf The sender identity\&#39;s email used to filter the templates returned in the API. The API will return templates that were sent on behalf of the specified email address.
     * @param createdBy The templates can be listed by the creator of the template.
     * @param templateLabels Labels of the template.
     * @param startDate Start date of the template
     * @param endDate End date of the template
     * @param brandIds BrandId(s) of the template.
     * @param options
     */
    public async listTemplates (page: number, templateType?: 'mytemplates' | 'sharedtemplate' | 'all', pageSize?: number, searchKey?: string, onBehalfOf?: Array<string>, createdBy?: Array<string>, templateLabels?: Array<string>, startDate?: Date, endDate?: Date, brandIds?: Array<string>, options: optionsI = {headers: {}}) : Promise<returnTypeT<TemplateRecords>> {
        const localVarPath = this.basePath + '/v1/template/list';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling listTemplates.');
        }

        if (templateType !== undefined) {
            localVarQueryParameters['TemplateType'] = ObjectSerializer.serialize(templateType, "'mytemplates' | 'sharedtemplate' | 'all'");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['PageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['Page'] = ObjectSerializer.serialize(page, "number");
        }

        if (searchKey !== undefined) {
            localVarQueryParameters['SearchKey'] = ObjectSerializer.serialize(searchKey, "string");
        }

        if (onBehalfOf !== undefined) {
            localVarQueryParameters['OnBehalfOf'] = ObjectSerializer.serialize(onBehalfOf, "Array<string>");
        }

        if (createdBy !== undefined) {
            localVarQueryParameters['CreatedBy'] = ObjectSerializer.serialize(createdBy, "Array<string>");
        }

        if (templateLabels !== undefined) {
            localVarQueryParameters['TemplateLabels'] = ObjectSerializer.serialize(templateLabels, "Array<string>");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['StartDate'] = ObjectSerializer.serialize(startDate, "Date");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['EndDate'] = ObjectSerializer.serialize(endDate, "Date");
        }

        if (brandIds !== undefined) {
            localVarQueryParameters['BrandIds'] = ObjectSerializer.serialize(brandIds, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(localVarFormParams);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method === 'POST') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeT<TemplateRecords>>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<TemplateRecords>(
                          resolve,
                          reject,
                          response,
                          "TemplateRecords",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "TemplateRecords",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            401,
                            "ProblemDetails",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Send the document by merging multiple templates.
     * @param mergeAndSendForSignForm The merge and send details as JSON.
     * @param options
     */
    public async mergeAndSend (mergeAndSendForSignForm?: MergeAndSendForSignForm, options: optionsI = {headers: {}}) : Promise<returnTypeI> {
        mergeAndSendForSignForm = deserializeIfNeeded(mergeAndSendForSignForm, "MergeAndSendForSignForm");
        const localVarPath = this.basePath + '/v1/template/mergeAndSend';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(mergeAndSendForSignForm, MergeAndSendForSignForm);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            mergeAndSendForSignForm,
            "MergeAndSendForSignForm"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method === 'POST') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeI>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse(
                          resolve,
                          reject,
                          response,
                          
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }



                        reject(error);
                    });
            });
        });
    }
    /**
     * 
     * @summary Send a document for signature using a Template.
     * @param templateId The template id.
     * @param sendForSignFromTemplateForm The send template details as JSON.
     * @param options
     */
    public async sendUsingTemplate (templateId: string, sendForSignFromTemplateForm?: SendForSignFromTemplateForm, options: optionsI = {headers: {}}) : Promise<returnTypeT<DocumentCreated>> {
        sendForSignFromTemplateForm = deserializeIfNeeded(sendForSignFromTemplateForm, "SendForSignFromTemplateForm");
        const localVarPath = this.basePath + '/v1/template/send';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams['content-type'] = 'application/json';
        } else {
            localVarHeaderParams['content-type'] = produces.join(',');
        }
        let localVarFormParams: any = {};
        let localVarBodyParams: any = undefined;

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling sendUsingTemplate.');
        }

        if (templateId !== undefined) {
            localVarQueryParameters['templateId'] = ObjectSerializer.serialize(templateId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        const result = generateFormData(sendForSignFromTemplateForm, SendForSignFromTemplateForm);
        localVarUseFormData = result.localVarUseFormData;

        let data = {};
        if (localVarUseFormData) {
          const formData = toFormData(result.data);
          data = formData;
          localVarHeaderParams = {
            ...localVarHeaderParams,
            ...formData.getHeaders(),
          };
        } else {
          data = ObjectSerializer.serialize(
            sendForSignFromTemplateForm,
            "SendForSignFromTemplateForm"
          );
        }

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            paramsSerializer: this._useQuerystring ? queryParamsSerializer : undefined,
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            responseType: "json",
        };

        if (localVarRequestOptions.method === 'POST') {
           localVarRequestOptions.data = data;
        }
        let authenticationPromise = Promise.resolve();
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        if (this.authentications["X-API-KEY"].apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications["X-API-KEY"].applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            return new Promise<returnTypeT<DocumentCreated>>((resolve, reject) => {
                axios.request(localVarRequestOptions)
                    .then((response) => {
                        handleSuccessfulResponse<DocumentCreated>(
                          resolve,
                          reject,
                          response,
                          "DocumentCreated",
                        );
                    }, (error: AxiosError) => {
                        if (error.response == null) {
                            reject(error);
                            return;
                        }

                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            200,
                            "DocumentCreated",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            201,
                            "DocumentCreated",
                        )) {
                          return;
                        }
                        if (handleErrorCodeResponse(
                            reject,
                            error.response,
                            422,
                            "ErrorResult",
                        )) {
                          return;
                        }


                        reject(error);
                    });
            });
        });
    }
}

function deserializeIfNeeded<T> (obj: T, classname: string): T {
  if (obj !== null && obj !== undefined && obj.constructor.name !== classname) {
    return ObjectSerializer.deserialize(obj, classname);
  }

  return obj;
}

type AxiosResolve<T> = (
  value: (returnTypeT<T> | PromiseLike<returnTypeT<T>>),
) => void

type AxiosReject = (reason?: any) => void;

function handleSuccessfulResponse<T>(
  resolve: AxiosResolve<T>,
  reject: AxiosReject,
  response: AxiosResponse,
  returnType?: string,
) {
    let body = response.data;

    if (
        response.status &&
        response.status >= 200 &&
        response.status <= 299
    ) {
        if (returnType) {
            body = ObjectSerializer.deserialize(body, returnType);
        }

        resolve({ response: response, body: body });
    } else {
        reject(new HttpError(response, body, response.status));
    }
}

function handleErrorCodeResponse(
  reject: AxiosReject,
  response: AxiosResponse,
  code: number,
  returnType: string
): boolean {
    if (response.status !== code) {
        return false;
    }

    const body = ObjectSerializer.deserialize(
        response.data,
        returnType,
    );

    reject(new HttpError(response, body, response.status));

    return true;
}

function handleErrorRangeResponse(
  reject: AxiosReject,
  response: AxiosResponse,
  code: string,
  returnType: string
): boolean {
    let rangeCodeLeft = Number(code[0] + "00");
    let rangeCodeRight = Number(code[0] + "99");

    if (response.status >= rangeCodeLeft && response.status <= rangeCodeRight) {
        const body = ObjectSerializer.deserialize(
            response.data,
            returnType,
        );

      reject(new HttpError(response, body, response.status));

      return true;
    }

    return false;
}
